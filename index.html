<script>
  const video = document.getElementById('video');
  const overlay = document.getElementById('overlay');
  const stage = document.getElementById('stage');
  const btnStart = document.getElementById('btnStart');
  const btnShot = document.getElementById('btnShot');
  const modeNone = document.getElementById('modeNone');
  const modeFrame1 = document.getElementById('modeFrame1');
  const modeFrame2 = document.getElementById('modeFrame2');
  const modeFrame3 = document.getElementById('modeFrame3');
  const fileInput = document.getElementById('customImg');

  let stream = null;
  let lastBlobUrl = null;
  let customImage = null; // HTMLImageElement or null
  // PNGフレーム画像
  let frame1 = null; // リゾートA
  let frame2 = null; // シーサーB
  let frame3 = null; // PLOWと写真
  let mode = 'frame1';

  function pad2(n){ return String(n).padStart(2,'0'); }
  function makeFilename(mode){
    const d = new Date();
    const y = d.getFullYear(), m = pad2(d.getMonth()+1), day = pad2(d.getDate());
    const h = pad2(d.getHours()), mi = pad2(d.getMinutes()), s = pad2(d.getSeconds());
    const labelMap = { frame1: 'resortA', frame2: 'shisaB', frame3: 'plow', none: 'noframe' };
    const label = labelMap[mode] || 'other';
    return `runuki-${y}${m}${day}-${h}${mi}${s}-${label}.jpg`;
  }

  // サイズ調整
  function fitOverlayToVideo(){
    const rect = stage.getBoundingClientRect();
    overlay.width = rect.width; overlay.height = rect.height;
    drawOverlay();
  }
  new ResizeObserver(fitOverlayToVideo).observe(stage);

  // カメラ開始
  btnStart.addEventListener('click', async () => {
    try {
      if(stream){ return; }
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
      video.srcObject = stream; await video.play();
      btnShot.disabled = false;
      fitOverlayToVideo();
    } catch(e){
      alert('カメラが起動できませんでした。権限やHTTPSをご確認ください。\n' + e);
    }
  });

  // モード切替
  function setMode(m){ mode = m; drawOverlay(); }
  modeNone.onclick = () => setMode('none');
  modeFrame1.onclick = () => setMode('frame1');
  modeFrame2.onclick = () => setMode('frame2');
  modeFrame3.onclick = () => setMode('frame3');

  // カスタム画像の読み込み
  fileInput.addEventListener('change', (ev)=>{
    const f = ev.target.files?.[0];
    if(!f) return;
    const img = new Image();
    img.onload = ()=>{ customImage = img; drawOverlay(); };
    img.src = URL.createObjectURL(f);
  });

  // ライブ用オーバーレイ描画
  function drawOverlay(){
    const ctx = overlay.getContext('2d');
    const w = overlay.width, h = overlay.height;
    ctx.clearRect(0,0,w,h);

    if(mode === 'frame1' && frame1){
      drawImageFrame(ctx, frame1, w, h);
    } else if(mode === 'frame2' && frame2){
      drawImageFrame(ctx, frame2, w, h);
    } else if(mode === 'frame3' && frame3){
      drawImageFrame(ctx, frame3, w, h);
    }

    if(customImage){
      const cw = Math.min(w, h) * 0.45;
      const ch = cw * (customImage.height / customImage.width);
      ctx.globalAlpha = 0.95;
      ctx.drawImage(customImage, w - cw - 12, h - ch - 12, cw, ch);
      ctx.globalAlpha = 1;
    }
  }

  function drawImageFrame(ctx, img, w, h){
    // 画像比率を保ったまま全面にフィット
    const ratio = Math.min(w / img.width, h / img.height);
    const iw = img.width * ratio;
    const ih = img.height * ratio;
    const x = (w - iw) / 2;
    const y = (h - ih) / 2;
    ctx.drawImage(img, x, y, iw, ih);
  }

  // 撮影（自動保存ON、ダウンロードボタン無し）
  btnShot.addEventListener('click', async ()=>{
    if(!stream || video.readyState < 2){ alert('カメラを開始してください。'); return; }

    // キャプチャ用キャンバスを動画サイズに
    const vw = video.videoWidth, vh = video.videoHeight;
    const canvas = document.createElement('canvas');
    canvas.width = vw; canvas.height = vh;
    const ctx = canvas.getContext('2d');
    // 映像
    ctx.drawImage(video, 0, 0, vw, vh);
    // オーバーレイ（動画サイズに合わせてリドロー）
    if(mode === 'frame1' && frame1){
      drawImageFrame(ctx, frame1, vw, vh);
    } else if(mode === 'frame2' && frame2){
      drawImageFrame(ctx, frame2, vw, vh);
    } else if(mode === 'frame3' && frame3){
      drawImageFrame(ctx, frame3, vw, vh);
    }
    if(customImage){
      const cw = Math.min(vw, vh) * 0.45;
      const ch = cw * (customImage.height / customImage.width);
      ctx.globalAlpha = 0.95;
      ctx.drawImage(customImage, vw - cw - 24, vh - ch - 24, cw, ch);
      ctx.globalAlpha = 1;
    }

    canvas.toBlob((blob)=>{
      if(lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
      const url = URL.createObjectURL(blob);
      lastBlobUrl = url;
      const fname = makeFilename(mode);
      triggerDownload(url, fname); // ★撮影ごとに自動保存
    }, 'image/jpeg', 0.92);
  });

  // 自動保存（iOS対策つき）: 引数でURLとファイル名を受け取る
  function triggerDownload(url, name){
    if(!url) return;
    const a = document.createElement('a');
    a.href = url;
    if('download' in HTMLAnchorElement.prototype){
      // Android/PCなど download属性が効く場合
      a.download = name || makeFilename(mode);
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    } else {
      // iOS Safariなど：新しいタブで開いて「写真に保存」
      window.open(url, '_blank');
    }
  }

  // 画像フレームのプリロード
  function preload(src){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.onload  = ()=> { console.log('loaded:', src); resolve(img); };
      img.onerror = ()=> { console.warn('failed:', src); reject(new Error('画像を読み込めません: ' + src)); };
      // キャッシュ回避
      img.src = src + '?v=' + Date.now();
    });
  }

  (async ()=>{
    try { frame1 = await preload('images/frame1.png'); } catch(e){}
    try { frame2 = await preload('images/frame2.png'); } catch(e){}
    try { frame3 = await preload('images/frame3.png'); } catch(e){}
    fitOverlayToVideo();
    setMode('frame3'); // 起動時にPLOWと写真を表示
  })();
</script>
